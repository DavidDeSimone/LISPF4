          **** IMPLEMENTATION GUIDE ****
 
HOW TO IMPLEMENT LISP F4 ON YOUR COMPUTER.
 
The LISP F4 system consists mainly of three parts:
A.  The interpreter (master version) written in FORTRAN IV
B.  'SYSATOMS' A file which will be read by LISP F4 at initiation.
C.  Additional functions, written in LISP.
 
For easy implementation do as follows:
 
1. (this section is removed)
 
2.  If you want to generate your own version or change one of the pre-
designed versions, here are the variables at hand.
 
NAME       REMARK                               CORR. ARRAY IN COMMON
 
JBYTES     Bytes in a Lisp pointer
IBYTES     Bytes in an integer
BYTES      Bytes in a real number
           (BYTES and IBYTES must be multiple of JBYTES)
NATOM=n    No of atoms                          PNP(n+1)
NFREET=f   f > 2*n.  No of atoms + cons cells   CAR(f), CDR(f)
NSTACK=s   s > 500                              STACK(s)
NHTAB=h    h == 1.5*n                           HTAB(h)
                  == means "about"
NPNAME=p   p == 2*n                             PNAME(p+2)
HILL=hill  size of parameter stack              jack(hill),jill(hill)
           hill == s

IRESOL     The precision of a floating point number (in decimal digits).
IPOWER     max(abs(p)), if floating point numbers are represented as
           m*10**p, abs(m)<10
FUZZ       will compensate for truncation errors in certain cases.
           Should be set to 5*10**(-IRESOL)
NBYTES=nb  nb = 2**x, where x = no of bits in a
           byte (normally x = 6 for BCD, 7 for
           ASCII and 8 for EBCDIC).
           (Can be 8 for ascii too)
MAXBIG     The largest positive integer that fits in a full word.
MAXINT     The largest positive integer that fits
           in the word size used for CAR and CDR.
           (If you don't use half word integers,
              MAXINT = MAXBIG).
CHDIV=d    Used for calculating an index from a
           character.  If CH is an INTEGER,
           holding a character left justified the
           value of i=ABS(CH/d)+1 must be in the
           range (1,nb).  CHDIV is only used in
           routines GETCHT and SETCHT.  Make sure
           that they work!  If they do not, LISP F4
           will fail while reading the SYS-atoms
           and consequently never reach the LISP
           top-loop.
im         = MAXMESS*NBMESS/IBYTES              IMESS(im)
           Don't forget to redimension IMESS!

  The remaining system variables need only be changed in certain cases.

MAXMESS    Number of messages
NBMESS     Max number of characters in a message
           Change it only when you add more
           (and longer) messages to the system.
LUNIN=li   Logical input.
LUNUT=lu   Logical output.
LUNSYS=ls  Logical unit for the SYS-atoms.
MAXLUN     The largest logical unit number allowed
IOBUFF     Size of ABUFF, BUFF,RDBUFF and PRBUFF
           Normally = 150.
NCHTYP=c   No of different "character types"
           such as ( ) [ ] etc.
NAREA      Length of common /B/ from ARG to
           DREG(7).
 
 
3.  Depending on how many bytes an INTEGER can hold you may have to
change the FORMAT(...,A4) in RDA4 and WRA4 to FORMAT(...,A5) (or
whatever)
 
4.  If your compiler requires it, insert a PROGRAM statement at the
beginning of the FORTRAN code.
 
5.  Observe, that the COMMON block is separated from the rest of the
FORTRAN code and replaced by:
 
     INCLUDE 'F4COM.FOR'
 
instead.  This makes it easy to change the common block.
 
6.  Non-standard FORTRAN routines

The routines GETCH and PUTCH are normally coded in assembler.  They
are used for moving bytes (characters) to/from an array.  They can
also be coded in Fortran if your Fortran dialect allows for byte
manipulation. The subfile VAXFNT contains this Fortran code for VAX11
Fortran.

  Calling format:

      CALL PUTCH(VEC,CH,I) Move to place I in VEC from the character CH.
      CALL GETCH(VEC,CH,I) Move from place I in VEC to the character CH.
 
The character in CH is left justified (with space padding).  Characters
in VEC are numbered 1,2,.... (1 = the leftmost one). 
Note that some computers (e.g. VAX11) store characters right justified.  

The following three operating system dependent subprograms are
initially dummy defined. If you want them to work correctly you have
to define them according to your operating system.

The subroutine MSLFT(I) returns the number of milliseconds left in
the job. This value can be used to test how much time is left in the job
when you are running in batch. Nowadays lisp is usually run interactively
and the function is somewhat obsolete. On the DEC20 implementation
mslft returns number of milliseconds cpu time the job has consumed and
is used mainly for timing purposes.

The subroutine MDATE(ISTR) sets ISTR to the current date as a 
10 character string. If your computer returns date in an other format
that is not 10 characters (maybe 8 or 12) you will also have to change
in the HEART routine, the change is easy you have to tell the length in
2 places that are marked in the code. Search in the code for mdate and
change the two 10's to whatever length you use.

The subroutine MTIME(ISTR) sets ISTR to the current time of day.
If your time format is not 5 characters you must change the code as above.


The subroutine BRSET without arguments is used for setting up terminal
interrupts. BRSET should set up the interrupt so that the subroutine
BRSERV without arguments is called whenever the user types a predefined
break character (e.g. CTRL-H on DEC20, CTRL-C on VAX11, BREAK on IBM).

It is very machine dependent how you trap interrupts. If the
specification above is difficult to implement you can do it in some
other way.  The way it works is that whenever the user types a break
character the logical variable IBREAK in the common /A/ should be set
to .TRUE.

7.  It is now time to compile and run the system.  Assign your input
(LISP-CODE) to logical unit li (normally teletype), and your output to
lu (normally teletype).  The file SYS-atoms should be assigned to
logical unit ls.  If all is OK so far, the system starts (after
reading the SYS-atoms) with a message
   LISP F4, LATEST UPDATE =
   .....
 
That is, when lispf4 starts it will read the system atoms from
the unit ls (unit 23 in the distributed code). When the system atoms
are read Lispf4 will write a message on unit lu (unit 5 in the code)
and start reading expressions from unit li (5 in the code). If everything 
works you should now be able to type in forms and get them evaluated.
i.e you type (PLUS 6 7) after the prompter and lispf4 answers 13.


8.  Read those LISP-package you want to use.
To change the standard input in the "scratch" system, use
   (IOTAB 1 unit)
You may choose between:
   BASIC1          (this one is necessary)
   BASIC2
   IO1
   FUNC1           DE, DF etc
   DEBUG1          BREAK,ADVISE, TRACE
   DEBUG1          BREAK1, error
   MAKEF           MAKEFILE
   EDIT            STRUCTURE EDITOR
 
You must of course have assigned the files above to a unit in some
way before you try to read them.


9.  For convenience you may now save your system by doing
    (ROLLOUT unit)
 
This file must also some way have been assigned to unit.

10.  Next time you enter LISPF4 start with (ROLLIN unit).
 
11.  Or, if you want to, replace the subroutine INIT2 by CALL ROLLIN(unit)
and you will not need the SYS-atoms any longer.
 

Once more

compile all the code
somehow assign

    the file SYSATOMS      to unit LUNSYS (variable you set in intit2)
    the terminal (input) to unit LUNINS            "--"
    the terminal (output)to unit LUNUTS            "--"
 
  optionally (but needed if you want to read lispcode or do a rollout)

     the file BASIC1     to unit X
              BASIC2     to unti Y
                .................

     some file (why not LISPROLL) to untin Z


     now you can read BASIC1 by doing (IOTAB 1 X) etc.
     or save the system by (rollout Z).

If your system allows dynamic opening of files you can change the
code in init2 so that lispf4 opens the file SYSATOMS at runtime, in
this way you will not have to assign the lunsys unit to the file. A
commented portion in the code shows how this can be done in DEC20
fortran.

In the same way you could of course open the terminal for input on LUNINS
and output on LUNUTS if it is needed. This is not the case on DEC20.

You can also write the function OPENF so that it works on your machine
and then you don't have to assign any files before you run LISPF4. The
OPENF function is documented later in this paper. The distributed code
contains a dummy definition of this function. Code that shows how this 
function is implemented for DEC20 is also supplied.

Additional hints:
 
- The range for small integers (MAXINT-BIGNUM)/2 should not be too
small.  Make it > 1000.
 
- The routine GARB may call LISPF4 "recursively" in case of error.
This is done only in order to offer the user a nice error handling,
but if your OS checks (and prohibits) "recursive" calls in FORTRAN you
must either do it indirectly through an assembler routine or replace
the call by an "error-return" by locking the stacks and placing an
error code at the top of FSTACK.    
 
INTERNAL REPRESENTATIONS.
 
On the next page there is a picture of the most important areas and
pointers used by the system.  Pointers are marked with straight arrows
(--------> ) and the flow of character are marked with sparse arrows
( - - - - -> ).
 
Alpha numerical atoms:
 
Let us follow what will happen when the atom FOO is read and printed.
FOO is stored in RDBUFF by a previous FORTRAN-READ (with A1 format).
RDPOS points to "the next character to be read".
FOO is now inserted into ABUFF and escape characters are moved.  Before
being moved the character is used as an index in CHTAB to determine its
type.  A hash address is calculated and used as entry in HTAB.  Suppose
that FOO has not been read before.  After finding an empty place in HTAB
this place is updated to point to NATOMP and NATOMP is increased by one
(new atoms are stored consecutively).  Suppose that NATOMP had the old
value i.  The printname FOO is now stored in PNAME, JBP is
updated to point to the next empty character position in PNAME.
(Also printnames are stored consecutively starting from the bottom).
The starting address for the printname is stored in PNP(i) and the
ending address+1 is stored in PNP(i+1).  A pointer to the atom NOBIND
is placed in CAR(i) and CDR(i) is set to NIL.  Finally the pointer
i is returned to the caller.
If later on FOO is to be printed, the print routine recognizes FOO as
an atom (the pointer value i is below NATOM).  The printname is
fetched using PNP(i) and PNP(i+1) and moved to the PRBUFF at position
PRTPOS.  While moving CHTAB is consulted to check if escape characters
(%) are needed.  When PRBUFF is filled up (PRTPOS > MARG) or if
terpri() is called, the line is printed using FORTRAN-WRITE with
format (1X,150A1).
 
Important arrays and pointers in LISP F4.
 
  Address space:                       Length = NATOM
 1                                           //                    MAXINT
 I---------------I-------------------I---------------I--------!-------I
NIL         NATOM  NFREEB      NFREET          BIGNUM      NUMADD
    atoms and           lists           real numbers    small integers
    strings
 
            RDBUFF  (read buffer)
           I- - - I------------------------------------I - - - - - I
           I      I          FOO                       I           I
           I- - - I------------------------------------I - - - - - I
            1      LMARGR    !                     MARGR      IOBUFF
   CHTAB                    RDPOS
 I-----I NBYTES              !
 I     I                     !
 I     I   consulting        !
 I     I<----------------->  !
 I     I                     !
 I-----I 1 !- - - - - - - - -!
           !
           !ABUFF   (print name buffer)
           I--------------------------------------------I
 i-------- IFOO                                         I
 i         I--!-----------------------------------------I
 i          ! ABUP1
 i          !
 i          !- - - - - - - - - - - - - - - - - - - - -!       JBP --!
 i                                                    !             !
 i <- hash address                                    !             !
 i                                                    !             !
 i  HTAB        CAR     CDR              PNP          !  PNAME      !
 i I----I    I-------I-------I          I---I      I--!-------------!-I
 i I    I 1  I       I       I NIL      I   I 1    I  !             ! I
 i I    I    I       I       I          I   I      I  ! printnames  ! I
 i I    I    I       I       I          I   I      I  !             ! I
 i I----I    I       I       I          I   I      I  !->FOO- -!    ! I
 ->I  -----i I-------I-------I          I---I      I     ! !   !    ! I
   I----I  i->NOBIND I  NIL  I  <- - -> I  --------------! !   !    ! I
   I    I    I-------I-------I  same    I---I      I       !   !    ! I
   I    I    I       I       I  index   I  ----------------!   !    ! I
   I    I    I       I       I          I---I      I           !    ! I
   I    I    I       I       I          I   I      I           !    ! I
   I    I    I       I       I          I   I      I   !- - - -!    ! I
   I    I    I       I       I NATOMP   I   I      I   !            ! I
   I    I    I---------------I          I   I      I   !            ! I
   I    I    I Unused atom   I          I   I      I   !          <-! I
   I    I    I space         I NATOM    I   I      I- -!- - - - - - - I
   I    I    I---------------I          I   I      I   ! real numbers I
   I    I    I       I       I NFREEB   I   I      I   !              I
   I    I<-! I       I       I          I   I      I---!---!----------I
   I    I  ! !       I       I          I   I          !   !    NPNAME
   I----I  ! I       I       I          I   INATOM+1   !  NUMBP
    // NHTAB I   free list   I NFREEP   I---I          !
  hash-      I   start       I           //            !
  table      I       I       I         byte address    !
             I       I       I         in PNAME        !
             I-------I-------I NFREET                  !
                                                       !
                          !- - - - - - - - - - - - - - !
                          !                 CHTAB
                          !                I-----I
                          !                I     INBYTES
                          !   consulting   I     I
                          ! <------------->I     I
                          !                I     I 1
                          !                I-----I
  PRBUFF  (print buffer)  !
 I------I--------------------------------I- - - - - - -I
 I      I                FOO             I             I
 I------I--------------------------------I- - - - - - -I
  1      LMARG            PRTPOS    MARG         IOBUFF
 
Small integers:
 
The address space NFREET + NATOM - MAXINT is reserved for small integers,
and they are stored in the list structures as pointers.  The numerical
value of a small integer is pointer-NUMADD.
 
Floating point numbers:
 
Real numbers are represented as pointers in the address space NFREET + 1
- BIGNUM.  The length of this range is NATOM.  The integers themselves
are stored consecutively as full word integers in PNAME starting form
the top and using NUMBP as "free real space pointer".  When no more
 
Strings:
 
do not have an entry in HTAB but a pointer to the atom STRING is
stored in CAR(i).  ("" are removed from the printname by the read
routine and added if asked for by the print routine).
 
Substrings:
 
representing atoms and strings (1,NATOM).
CAR(substring) = SUBSTR
CDR(substring) = (sourcestring start . length)
Substrings do not have a  printname of it's own (and thus do not occupy
space in HTAB or PNAME).
 
Lists:
 
The variable NFREEP points to the free list.  After a compacting
garbage collection the free list is a consecutive list of cons cells
starting from NFREEP and growing backwards down to NFREEB.
 
ARRAYS are stored in a way similar to that of atoms and stings.
All array data are stored in the Fortran array PNAME.  Arrays are
referred to by pointers in the range (T+1,NATOM).  Every array
consists of three parts, each one of which may have zero length.
The details are as follows:
 
             (z is zero or more slack bytes.)
             (i,j,k,l are byte pointers into PNAME.)
 
x        = the array pointer value
CAR(x)   = LISPF4-ARRAY
CDR(x)   = NIL
PNP(x)   = i
PNP(x+1) = l
 
PNAME:
 ....(z j k (pointers) z (integers) z (f. p. n.)) ....
      !                !            !             !
      i                j            k             l
 
The three array parts all start on a word boundary.  By a word we
mean the basic storage cell for a data type.  (E.g. half machine
word, full machine word, double machine word, etc.).
 
By this means it is possible to call a Fortran subroutine with an
actual parameter consisting of an address to an array part if the
corresponding formal parameter is a properly typed array.  The
advantage of this method, instead of having pointer arrays, is that
we do not have to "unbox" and "box" numbers before and after calls
to e.g. numerical routines.  For further details see the description
of subroutine ARRUTL.
 
RECURSIVE PROGRAMMING IN FORTRAN.
 
The definition of the LISP F4 interpreter is highly recursive
and in this chapter we will explain how recursion has been programmed.
 
The stack:
 
There are two stacks for recursive calls of sub functions.  One stack
(named ASTACK) is used for saving values which are to be saved during
a recursive call.  The other stack (named FSTACK) is used to hold
return jump indicators, here represented as integers which are used in
a computed GOTO-statement.  Both ASTACK and FSTACK are physically
stored in the same vector STACK using IP and JP as stack-top pointers.
 
                 STACK
  NSTACK ----> ---------
               I  val  I
               I  val  I          part ASTACK
               I  val  I
       JP ---> I  val  I
               I       I
               I       I
               I       I
       IP ---> I  ret  I
               I  ret  I
               I  ret  I          part FSTACK
               I  ret  I
        1      ---------
 
Pushing and popping are done by the routines
 
        APUSH APUSH2 APUSH3
        APOP  APOP2  APOP3
        FPUSH
 
and sometimes (for efficiency) in line as in
        998 I = STACK(IP)
            IP = IP - 1
 
Recursive calls and returns:
 
All recursive functions are coded in the FORTRAN subroutine LISPF4.
That means that they are not subroutines themselves but just pieces of
FORTRAN code.

A call is performed by saving all necessary values with APUSH (or APUSH2,
APUSH3) and by saving a return jump indicator with FPUSH.
After all this pushing follows an unconditional GOTO to the "function"
and that follows (normally) a statement with the same statement number
as indicated by IND, there the execution is to continue at return from
the calling function.  Saved values are then fetched by a proper number
of calls to APOP.

A return form a recursive function is done by GOTO 998 where the
indicator saved on FSTACK is popped and used in a computed GOTO-
statement leaving the program control to the caller.
 
N.b.
In order to give the user a change in case of stack overflow, we have
done the following:

Whenever the difference JP-IP becomes less than a preset value MIDDL,
MIDDL is divided by 2 and SYSERROR is called (which in turn normally
calls the break package).  When MIDDL has become too small RESET is
performed and MIDDL is reinitialized to its original value.
 
THE EVAL-APPLY SYSTEM.
 
Eval-apply and all SUBR's and FSUBR's are handled by (or called from)
the subroutine LISPF4 which is "the heart of the interpreter".
Calling format is
 
       CALL LISPF4(IND)
 
where IND = 1 means "this is the first call to LISPF4".
          = 2 means "restart the interpreter"

 
The top level loop is defined as
 
      lispx();
      error();
      reset();
 
where lispx() is a SUBR defined as
 
      loop:  print(eval(read())); go loop;
 
but may be redefined by the user.
 
Transmission of arguments:
 
The variables ARG, ARG2 and ARG3 are reserved to hold the first three
arguments to SUBR's.

In case of SUBRN (see below) and FSUBR arguments are pushed onto ASTACK
and the number of arguments are held in the variable IARGS.  The value
of a function is assigned to IRES before returning and IRES is
EQUIVALENCE'd to ARG.  (Sometimes an argument just passes through).
In addition the variable FORM holds the form currently under
execution.
 

               Variable bindings in  lispf4
 

LAMBDA, NLAMBDA and PROG variables are pushed onto the parameter
stack (the arrays JACK and JILL) in traditional manner.  This list
should be thought of as a simulated variable stack (and is used
implicitly by eval, apply, setq, etc.).
 

Lispf4 uses a stack for bindings very much like interlisp.  Each slot
on the stack holds variable name and value. In the fortran code the
stack is made up of two arrays JACK and JILL. At any given moment the
global variable ENV points to the position of the stack that is the
environment. A global variable TOPS points to the last used slot on
the stack.

When eval evaluates a variable it will first scan the stack starting
at ENV.  If no value is found it will then look in the value-cell
(i.e. CAR) of the atom and if there is no value there then there is
an error.  When we enter a function we must bind its lambda variables
on the stack and when we leave the function we must restore the
stack as it was before.

To do this we bind variables in blocks on the stack. One block for
each function. These blocks must contain information to make it
possible to remove them when we leave a function. This information
is kept in the tops marker slots. For debugging (and also used
internally) purpose we keep the form (i.e. usually function call) in
the bottom marker.  A picture of the stack after 2 function call is
showed below.  In the first block the variable (atom) FUM is bound
to -23 and the variable FOOBAR is bound to nil.

            JACK         JILL

                 top marker
ENV -->    -------------------------
           ! BAR       !   77      !
           ! FOO       !   88      !
           -------------------------
                 bottom marker
                 tops marker
           -------------------------
           ! FUM       !   -23     !
           ! FOOBAR    !   NIL     !
           -------------------------
                 bottom marker



     The bottom and top marker.

The top marker must hold information that makes it possible for us
to restore the stack after a function call. JILL of the tops marker
points to the previous tops marker. This makes it possible to drop
the block by doing TOPS =: JILL(TOPS). We also must restore the
environment and JACK of the topmarker points to previous
environment. Thus we restore the environment by doing ENV =: JACK(ENV).

But couldn't TOPS and ENV be the same?  No. Some functions don't
bind variables on the stack (SUBR and FSUBR). We also want to be
able to evaluate some forms in an environment that we manipulate
ourself.  A funarg expression would put it's bindings on the stack
but would let it's topmarker JACK (the environment pointer) point
to 0.

When we look for bindings on the stack we start in the block pointed
to by ENV. After we have searched that block we follow this block's
environment pointer (that's JACK) to the next block. When we find an
environment pointer that points to 0 we are ready.

When we leave a function we always drop the block on tops of the
stack.  If the function was one that binds variables on the stack we
also restore the environment.

The bottom marker holds in JACK a pointer to *FORM
and in JILL a pointer to FORM


Lets see what the interpreter does when we evaluate a user defined
function.
           The form is (FOO FIE FUM (SETQ BAR 77))
           FOO is defined  (DE FOO (X Y)(CONS X Y))


          LAMBDA and NLAMBDA case
          =====================
           1. Put bottom marker 
                 PREV := TOPS-1    ! we must remember the previous block
                 JACK(TOPS) := *FORM
                 JILL(TOPS) := FOO FIE FUM (SETQ BAR 77)
                 TOPS := TOPS+1
           2. Find the lambdalist (X Y)
           3. Find arglist        (FIE FUM (SETQ BAR 77))
           4. Take first element in the lambda list
              put it in JACK(TOPS)
              take first element of arglist
              put it in JILL(TOPS)
              arglist := rest(arglist)
              lambdalist := rest(lambdalist)
              TOPS := TOPS+1
              repeat step 4 until arglist is empty.
              If the lambdalist becomes empty before
              the arglist someone has called a function
              with more arguments than the function can use.
              This is not what I call good programming but it's
              allowed in interlisp and therefore allowed in LISPF4.
              The extra arguments all get the name -*-.
              The extra arguments are evaluated so if the evaluation
              has side effects you could use this (miss)feature.

           5. Put the top marker 
                JILL(TOPS) := PREV

               Now we must evaluate all the arguments.
               At this time the bindings in this block
               are not in the environment so we can
               use JACK(TOPS) to something else.
               We temporary let JACK(TOPS) := JILL(TOPS)
               And we let JILL(TOPS) point to the argument
               under evaluation.

                The tops block now looks like this

                                                            !- TOPS (global
              !--  LINK,,LINK -------------------------!  <--     variable)
    link      !    -*- (SETQ BAR 77)                   ! link to
    to        !     Y  FUM                             ! argument
    prev.     !     X  FIE                             ! under
    block     !   *FORM (FOO FIE FUM (SETQ BAR 77))  <-! evaluation
              !
              !->  LINK,,LINK


 Now you call eval with each argument. When the argument is
evaluated its put in JILL(JILL(TOPS)) and JILL(TOPS) is increased by 1.
When all arguments are evaluated we let JILL(TOPS) := JACK(TOPS)
JACK(TOPS) := ENV, ENV := TOPS.

Then we call eval with the body of the function.



Representation of SUBR's and FSUBR's etc.
 
The type of a function (if not LAMBDA or NLAMBDA) is indicated by the
pointer value of the atom itself as seen in the following picture:
 
 NIL
I----------I----------I----------I----------I----------I----------I--...
 1       SUBR0      SUBR1      SUBR2      SUBR3      SUBRN      FSUBR
 
I                          SUBR's                      I FSUBR's    I
 
SUBR's with no arguments are numbered in the range 1-SUBR0 and so on
for SUBR1, SUBR2 and SUBR3.  In the range SUBR3+1 - SUBR we have
SUBR's with an indefinite number of arguments (as PLUS).  FSUBR's are
numbered in SUBR+1 - FSUBR.

These conventions make it easy for apply to determine the proper
argument actions and then jump to the corresponding code using the
pointer value of the atom in a computed GOTO.
(SUBR . f) or (FSUBR . f) in the case of FORTRAN coded lisp functions.
In practice getd(f) is used inline in eval-apply and does not
construct the list (SUBR . f), but as (SUBR . f) is a legal function
form, cases like ((SUBR . f) ...) are also taken care of.
 
Error handling:
 
Two classes of errors may occur in the system.
 
1.  Hard errors - reset() is called.
detected inside LISPF4) or perform CALL LISPF4(2) if detected by an
other subroutine (garb is the only subroutine that does this).

 
2.  Soft errors - syserror() is called.
All these errors jump to a place where a call to
 
          syserror(errno, fn, args, form)
 
is built up and sent to apply for further action.
RESET.  Normally SYSERROR is redefined in lisp to make use of the
break package after the message.
 
 
Though eval-apply works as given in appendix B not all help functions
are called but placed inline.  Moreover it does not recursively call
EVAL when the form to be evaluated is the last one in
- PROGN
- a LAMBDA body
- a COND or SELECT clause.
 
Especially as (LAMBDA (..) S) is quite a common expression this little
trick saves a lot of good stack storage when recursion digs down.
 
 
HOW TO ADD NEW SUBR's AND FSUBR's

There are two ways of adding Lisp functions to the interpreter. The
simplest way is to use XCALL(NO,ARGS); the other way is to add inline code
to the heart of the interpreter, i.e. LISPF4.

1. How to use XCALL

The SUBR XCALL is initially dummy defined to return NIL. However, it can
be used as a handle for calling Fortran subprograms form Lispf4. To do this
you have to add code to the Fortran function XCALL(NO,ARGS), by using the
NO as a 'code selector' and ARGS as a list of arguments to the new routine.
In your Lisp program you then must call XCALL with the NO and ARGS belonging
to the Fortran routine you wish to call. Note that XCALL normally has to
convert Lisp data types into Fortran data types before calling the external
routine, and vice versa when returning a value. 

Note:
If your routine calls the Lispf4 interpreter, you have to write inline code
in Lispf4, making use of recursion conventions.

2. How to add new SUBR's to the heart of Lispf4

Do the following:

a) Insert the function name in the file SYSATOMS. The location of
the name is important. The functions are grouped after type and
number of arguments.  (the order is SUBR's with 0 args, SUBR 1
numerical arg, SUBR 1 non-numerical arg, SUBR 2 args, SUBR 3 args,
SUBR n args, FSUBR's). Place the name in the selected list in SYSATOMS
and remember the number of the location.

b) Change the corresponding computed GOTO statement in LISPF4, by
inserting a new statement number for the new function. Note that
each group of build in functions have their own computed goto in
LISPF4. The labels of these computed GOTOs correspond to the lists
in the file SYSATOMS.  It is also recommended that you add a comment at
the computed GOTO with the name of the new function.

c) Put your piece of code somewhere. You may access the arguments to
the function through the Fortran variables ARG, ARG2, ARG3. They can
also be found on the stack JILL where the variable IARGS is equal to
the actual number of arguments. The first arg is in
jill(index), second in jill(index+1) etc.  Normal return is done by
assigning IRES to the result value and then doing GOTO 998. If your
function is a FSUBR you should return to 999 and not to 998 as these
functions reset whatever stacks they use themselves.  You must
of course do that too. Look at AND to see how it is done.

Warning:  If you make use of CONS, MKNUM, or MATOM explicitly within
your new function (also in XCALL), you must save all references to
Lisp objects so that they can be found in case of garbage
collection. Be sure to always store pointers to Lisp objects you
want to keep in the Fortran variables TEMP1, TEMP2, TEMP3, ARG,
ARG1, or ARG2, because the garbage collection marking is done from
those variables.

ADVICE FOR SAVING SPACE IF YOUR COMPUTER IS A MINI.
 
- Do not use double buffering in I/O.
 
  Some operating systems gives a choice between single and double
  buffering as an option.  Use single!
 
- Rewrite some routines in assembler.
 
  Especially FORTRAN I/O is used in a very trivial manner, and is very
  easy to recode in assembler.  In many cases this will save a lot of
  program storage.
 
- Overlaying.
  The following routines never call each other directly or indirectly
  LISPF4 vs.  INIT1, INIT2.  (INIT2 ought to be replaced by a call to
  ROLLIN anyhow).
  (GARB MARKL REHASH ROLLIN ROLLOUT MOVE) vs.
  (LSPEX NCHARS EQUAL GET).
  But as the last list consists of very small routines only it is
  probably not worth overlaying.  However this list can be extended by
  the routines (IPRINT PRIN1 PRINAT TERPRI) if you remove the call to
  IPRINT and TERPRI from the routine GARB, rename GARB to GARB1 and
  define a small routine GARB which calls GARB1 and then does the
  IPRINT call.
  See also the cross reference listing given in appendix A.
 
- Removing code.
 
  a) In GARB.  Remove the parts that perform atom - bignumber and
  compacting gbc.  Also remove the recursive (inline) code for list
  marking and use MARKL only.
  Remove REHASH.
  This implies that ROLLIN/ROLLOU must read/write the entire list
  space and the hash table HTAB.
 
  b) In PRIN1.  Remove the parts that are active during pretty-print
  only.
 
COMMENTS ABOUT THE FORTRAN ROUTINES USED.
 
The FORTRAN routines are grouped in the following manner.  (See also
appendix A, where a cross reference listing is given).
 
1.  The "main" routine
    MAIN 
 
2.  Initiation routines.
    INIT1 INTI2
 
3.  The "heart" routine.
    LISPF4
 
4.  ROLLIN/OUT
    ROLLIN ROLLOU MOVE
 
5.  Garbage collection.
    GARB MARKL REHASH
 
6.  Input routines.
    IREAD RATOM SHIFT RDNUMB
 
7.  Output routines.
    PRIN1 PRINAT PRIFLO PRIINT TERPRI IPRINT
 
8.  Diverse help routines to LISPF4
    MATOM MKNUM MKREAL GETNUM GTREAL GETCHT SETCHT NCHARS
    LSPEX MESS XCALL
 
9.  Small routines, push and pop etc.
    APUSH APUSH2 APUSH3 APOP APOP2 APOP3 FPUSH CONS SUBST
    EQUAL GET GETPN COMPPN ARRUTL
 
10. I/O routines.
    LOPEN RDA1 RDA4 WRA1 WRA4 EJECT REW DUMPUT DUMPIN
    DMPIN2 DMPOU2 
 
11. Assembler routines.
    GETCH PUTCH 

12. Machine dependent routines that must be coded in
    assembler/fortran for each computer. These
    routines are supplied in a dummy format that does nothing
    but you have to write them to get date, time open symbolic
    files e.t.c

    MDATE,MTIME,MSLFT,OPENF
 
1.      The "main" routines.
 
1.1 SUBROUTINE MAIN

The main object is:
      CALL INIT1
      CALL INIT2
      CALL LISPF4(1)
      CALL LSPEX
 
 
 
2.      Initiation routines.
 
2.1 SUBROUTINE INIT1
Here all machine depended variables are set. 
 
2.2 SUBROUTINE INIT2
This routine reads the file SYSATOMS and sets up the character table,
the symbol table and the list-space memory.  Also some variables
corresponding to some LISP atoms are defined.  It is recommended that
INIT2 is replaced by a call to ROLLIN as soon as a working system is
generated.
 
3.      The "heart" routine.
 
3.1 SUBROUTINE LISPF4(IREE)
 
The eval-apply system and all FORTRAN coded LISP functions.
 
4.      ROLLIN/OUT.
 
4.1 SUBROUTINE ROLLIN(LUN)
 
Reads a file produced by ROLLOU from logical unit LUN.
If rollin is not possible NIL is returned otherwise the value is LUN.
If the size of any array has changed since the last ROLLOU a lot of
pointers must be updated.  This is done by the routine MOVE.
After reading, a new free list is constructed in the empty list space
and the atoms are "rehashed" using the routine REHASH in order to
establish a correct hash table.
Finally read and write buffers are cleared, REWIND LUN is performed
and LUN is returned as the value of ROLLIN.
 
4.2 SUBROUTINE ROLLOU(LUN)
 
The routine saves a binary pattern of the LISP memory to be used later
on (read by ROLLIN).
The following parts of the memory are written on logical unit LUN.
CINF(1-15)      The 18 first words in COMMON /A/.
                Used by ROLLIN to detect if rollin is
                possible.
IMESS(1-im)     All messages.
AREA(1-NAREA)   COMMON /B/ up to (and including) DREG(7).
PNAME(...)      Printnames.  Only used upper and lower parts.
PNP(...)        Printname pointers.  Only used lower parts.
CAR,CDR(...)    Only used lower(atoms) and upper(lists)
                parts.  The free list is not written.
BCOM(1-c)       COMMON /CHARS/.  (character variables).
CHTAB(1-nb)     The character translation table.
 
Before writing a compacting garbage collection is called in order to
save a lot of space and time by not writing the free list.
CINF(1-8) consists of those variables which must not be changed until
next ROLLIN.
CINF(9-15) are those local pointers which may be updated if the sizes
of arrays have been changed.
Help routines to do all writing are DMPOU2 and DUMPUT.
ROLLOU rewinds LUN before returning.
 
4.3 SUBROUTINE MOVE(DIFF,MIN,MAX)
 
Used by ROLLIN to add DIFF to pointers in the range MIN < p <= MAX.
Pointers p are taken from CAR,CDR and ARGS(1-10) where ARGS is
equivalent to ARG, ARG1, ARG2 etc. in COMMON /B/.
 
5.      Garbage collection.
 
5.1 INTEGER FUNCTION GARB(GBCTYP).
 
This is the routine responsible for garbage collection.  The kind of
gbc is indicated by GBCTYP:
 
        GBCTYP   action                           called from
        ------   ------                           -----------
        0        Normal gbc. List cells only.     CONS
        1        List compacting.                 ROLLOU
        2        Big numbers.                     MKNUM
        3        Big numbers and atoms.           MATOM, MKNUM, MKREAL
 
GARB may also have been called form LISPF4 (the LISP function
reclaim(gbctyp) ).

Here is a short description of the working behavior of the garbage
collector:
 
Step 1:
Mark active cells by negating CDR.  If big numbers gbc mark in the
vector PNP.  If atom gbc mark also in CDR of atoms (by temporarily
setting NFREEB = T + 1).
 
Step 2:
Select proper action depending on GBCTYP.
 
       0 goto step 7
       1 goto step 3
       2 goto step 5
       3 goto step 5
 
Step 3:
List compacting (GBCTYP = 1).
Move active CAR CDR to the top of free storage and unmark CDR.  Leave
new address  in CDR of moved cell.  Goto step 6.
 
Step 4:
Atom gbc (GBCTYP = 3).
Move active atoms to the lower part of atom space (lower CAR,CDR).
Leave new address in (negative) HTAB and unmark CDR.  Goto step 6.
 
Step 5:
Big numbers (GBCTYP = 2,3).
Move active numbers (marked in PNP) to the top of PNAME.  Leave new
address in old place in PNAME.  Reset PNP.  If GBCTYP = 2 then goto 6,
otherwise goto step 4.
 
Step 6:
Restore moved pointers (GBCTYP = 1,2,3).
 
Step 7:
Clear memory.
GBCTYP = 0,1    Construct a free list and return.
       = 2      Return.
       = 3      Rehash all saved atoms and return.
 
 
Marking active atoms and cells starts from:
- The COMMON variables ARG ARG2 ARG3 ALIST FORM TEMP1 TEMP2
      TEMP3 I1CONS I2CONS
- Current ASTACK (temporarily saved values).
- CAR and CDR of defined atoms.
 
In the marking phase, a list of all encountered arrays is built up.  The
list is headed by the variable ARRLST.  Then -CDR(ARRLST) points to the
next array etc., until we get to NIL.  The mark phase is finished by
four steps:
 
1.  If ARRLST = NIL then exit.
2.  S:= ARRLST;  ARRLST:=-CDR(S);  CDR(S):=-NIL.
3.  "Start marking from all pointers stored in the array S"
4.  Go to 1.
 
 
2 SUBROUTINE MARKL.

This is a non recursive marking routine used by GARB if local stack
inline code in GARB as it looks upon each cons cell twice.  But in
case of program space problems, you may use only MARKL and remove the
marking code in GARB.
The algorithm is described in Sc 67.
Treats arrays as in GARB.
 
5.3 SUBROUTINE REHASH.
This routine is used for constructing a new entry in HTAB for each
existing atom.  REHASH is called from ROLLIN and from GARB (when atom
gbc is asked for).
 
6.      Input routines.
 
6.1 FUNCTION IREAD(N).
 
(N is a dummy).
IREAD reads an S-expression into internal form.  (See also appendix B
where IREAD is defined in LISP).
It uses RATOM to read separate tokens such as atoms, numbers
parenthesises etc.
The value is a pointer to the constructed S-expression.
 
6.2 INTEGER FUNCTION RATOM(A,IOP).
 
Called by IREAD to read the next token from the input buffer RDBUFF.
(IOP = 1).
RATOM is also called from LISPF4 (IOP = 0).
RATOM classifies the token and returns a type (and a value in the
parameter A) as follows:
 
     token   returned value  returned in A
     -----   --------------  -------------
     atom          1            atom
      (            2            NIL
      )            3            NIL
      '            4            NIL
      .            5          the atom .
 
RATOM keeps [ and ] in a separate bracket stack and (if called from
IREAD) [ or ] are never seen but returned as ( or as a proper number
of )'s.
 
6.3 SUBROUTINE SHIFT(I).
 
Reads the next character from the input buffer RDBUFF (and reads a new
line into RDBUFF if necessary).   The character is returned in CHR and
the type of the character in CHT.  The table CHTAB is accessed with
the character value (range 1 - NBYTES) to determine the type.  (A list
of different types is given in LISPF4 - User guide).
 
If I = 1 at entry the previous CHR is stored in ABUFF (the buffer for
a printname given to MATOM).
 
If I = 3 at entry, the previous CHR belongs to a string under
construction and is stored in PNAME.
 
The escape character % is never returned by SHIFT but signals the next
character to be treated as a letter, digit, + or - sign (depending on
its type).
Normally SHIFT is called from RATOM (the flag IFLG2 =NIL) but
sometimes also from the code for unpack(x) in LISPF4 (IFLG2 = T).  If
called from unpack, characters are read from PRBUFF instead and all
characters are treated as if they were prefixed by a %.
 
6.4 INTEGER FUNCTION RDNUMB(INTG) OR
                           (FLO).

(This function does not exist in the code now. The parsing is done
inline in ratom.)
 
This routine is a scanner for a integer/floating point number with
the following syntax:
 
   number ::= sm ! smEsn
   s      ::= + ! - ! empty
   n      ::= d ! dn
   d      ::= 0 ! 1 ! 2 ! 3 ! 4 ! 5 ! 6 ! 7 ! 8 ! 9
   m      ::= n ! n. ! n.n ! .n
 
7.      Output routines.
 
7.1 SUBROUTINE PRIN1(S).
 
This is the routine which prints a S-expression.  The format of the
output is directed by SYSFLAG(i) as follows:
 
      SYSFLAG no      value      means
      ----------      -----      -----
         2            NIL        fast printing
                      T          pretty printing
         3            NIL        (QUOTE s) prints as (QUOTE s)
                      T          (QUOTE s) prints as 's
         5            NIL        Do not add % or "
                      T          Add % or " when so needed
                                 for correct read back.
                                 (This flag is checked by
                                  PRINAT).
                                 Only used during pretty-print.
         7            NIL        Do not begin a new line if
                                 the current expression will
                                 fit on line.
                      T          Begin a new line whenever a
                                 sublist is found unless it is
                                 the first (or sometimes second)
                                 sub-expression.
 
A definition of PRIN1 in LISP is given in appendix B.
 
7.2 SUBROUTINE PRINAT(X,NKW,JPOLD).
 
Prints an atom X or ... (if X = -1) or --- (if X = -2).
NKW is the number of '-s to be printed.
JPOLD is a saved stack pointer which is used to reset the stack in
case of error.
The printname is first stored in PRBUFF, then checked if it fits.
(That is why the size of the print buffer is twice maximum of a
printname).
If overflow has occurred TERPRI print the line up to the old print
position and then the printname for the atom is moved to the proper
position in PRBUFF.
For each character sent to PRBUFF a test by the routine GETCHT is
performed to check whether a % is needed or not.  This check is not
done if SYSFLAG(5) = NIL.
 
7.3 SUBROUTINE PRIFLO(F).
 
Prints the floating point number F.
 
7.4 SUBROUTINE PRIINT(I).
 
Prints the integer I.
 
7.5 SUBROUTINE TERPRI.
 
Writes PRBUFF on logical unit LUNUT and resets PRTPOS (the print
position) to LMARG (current left margin).  If called from NCHARS (the
flag IFLG1 is not = NIL) output is not printed but the numbers of
characters (= value of PRTPOS -1) is accumulated to IFLG1.
 
7.6 SUBROUTINE IPRINT(I).
 
         CALL PRIN1(I)
         CALL TERPRI
         RETURN
         END
 
8.      SOME AUXILIARY ROUTINES FOR LISPF4
 
8.1 FUNCTION MATOM(L).
 
At entry abs(L) character are stored in ABUFF.  If L > 0 MATOM
creates an atom otherwise a sting is constructed.
If an atom with the same printname already exists, that atom is
returned as the value of MATOM; otherwise a new atom is created.  If
no more space for atoms are left a compacting atom garbage collection
is performed.
 
8.2 FUNCTION MKNUM(N).
 
N is a full word integer.
value of N.
 
8.3 SUBROUTINE MKREAL(R).
 
Stores a floating point number in upper PNAME and returns a LISP pointer
to it.
 
8.4 INTEGER FUNCTION GETNUM(I).
 
Returns the FORTRAN integer value of a LISP number as an integer.
GETNUM converts real numbers to integers. The caller is responsible for
I to be a LISP number.
 
8.5 FUNCTION GTREAL(I,IRETUR).
 
pointer I.  IRETUR will contain the closest integer number.
 
If I points to a small integer, GTREAL will return 0.0 (but IRETUR
will still return the integer value).
 
8.6 INTEGER FUNCTION GETCHT(IC) AND SUBROUTINE SETCHT(IC,IT)
 
These routines are used for fetching/storing the internal type of a
character.  Calling format:
 
        I =GETCHT(IC)
        CALL SETCHT(IC,IT)
 
A character should be placed left justified in IC before calling.  The
integer value of that character is used as an index in the table
CHTAB.  The variable CHDIV is used to calculate this index by an
integer division.
with a new one (IT in SETCHT).
It is recommended to recode GETCHT and SETCHT in assembler.
(Or do this is some faster way than dividing)
 
8.7 INTEGER FUNCTION NCHARS(S,IFLG).
 
This routine is used by the LISP functions concat, pack, unpack and
nchars in order to create a printname representation in PRBUFF.  It is
done by saving the current print status (buffer and pointer) and
calling PRIN1 for each member in S (which is a list of S-expressions).
IFLG = T indicates that % is to be printed by PRIN1 when needed.
The flag IFLG1 is set to NUMADD (not NIL) to indicate to TERPRI that
IFLG1 (in order to count characters).
After calling NCHARS,
 
- concat   creates a string.  TERPRI builds the printnames from
           the print buffer.
- nchars   returns the number of characters.
- pack     creates an atom from the print buffer.
- unpack   creates a list of atoms by reading the print
           buffer character by character.
 
Before returning they must reset the print status.
 
8.8 SUBROUTINE LSPEX.
 
Exits from LISP F4 after writing statistical messages.  The exit is
done by the FORTRAN statement STOP. 
 
8.9 SUBROUTINE MESS(I).
 
If I = 0 then MESS was called from INIT2 and messages are read from
LUNSYS.  Otherwise a message corresponding to the no I is printed.
 
8.10 INTEGER FUNCTION XCALL(FN,L).
 
A dummy function (returns NIL) where you may add your own pieces of
FORTRAN codes such as calling other subroutines.  Use FN as a selector
in a computed GOTO and L as the argument list.  FN is a FORTRAN
integer at calling.
 
9.      Small routines, push and pop etc.
 
9.1 PUSHING AND POPPING
 
The following subroutines handle ASTACK, the upper part of the array
STACK.  JP points to the current top.
 
   APUSH(I) APUSH2(I,J) APUSH3(I,J,K)
    APOP(I)  APOP2(I,J)  APOP3(I,J,K)
 
(Pushing and popping are done from left to right in the argument
lists).
The subroutine FPUSH(I) pushes a statement number indicator onto
FSTACK, the lower part of STACK.  Here IP points to the current top.
 
address is put onto FSTACK (which forces LISPF4 to jump to the reset
label at next recursive return.).
 
Remark:  In the eval-apply system pushing and popping are coded
inline.  At the entrance of eval there is a check whether the stack
space left is reasonable.
 
9.2 INTEGER FUNCTION CONS(I1,I2)
 
Does cons(I1,I2).
In case of an empty free list garbage collection is activated (GARB).
If the number of free cons cells is less than ISPLFT a weak error is
triggered (SYSERROR - break) and ISPLFT is divided by 2.
ISPLFT is reset to 400 whenever a RESET is performed.
 
9.3 INTEGER FUNCTION SUBST(IX,IY,IS).
 
Does subst(ix,iy,is).
 
(this function is now replaced with SUBPR (substitute pairs) that
is much more general) SUBST is then defined in one of the lisp-packages
in terms of subpair.


9.4 INTEGER FUNCTION EQUAL(II,JJ).
 
Does equal(ii,jj).
 
9.5 INTEGER FUNCTION GET(J,I).
 
Does get(j,i).
 
9.6 INTEGER FUNCTION GETPN(X,MAIN,JB,IPL).
 
  MAIN   = Pointer to main string if substring.
  JB     = Byte offset in printname.
  IPL    = Byte length of printname.
  GETPN  = -1  X is invalid.
            0  if X literal atom.
            1  if X string or substring.
 
9.7 INTEGER FUNCTION COMPPN(X,Y).
 
              returns:           if:
               -2                x is invalid
               -1                x < y
                0                x = y
                1                x > y
                2                y is invalid
 
9.8 SUBROUTINE ARRUTL(IPTR,IACTN,IPART,IFIRST,ILEN).
 
This routine performs various array handling functions.
IPTR is a pointer to the array, IPART tells which part of it (1,2,or
3), and IACTN tells what action to be done:
 
IACTN = 1  get array element IFIRST
        2  set array element IFIRST
        3  set IFIRST  and ILEN to array part bounds
 
array part and ILEN is the number of elements.
 
10.     I/O routines.
 
10.1 REMOVED

 
10.2 SUBROUTINE RDA1(LUN,CARD,I1,I2,IEOF).
 
Reads from logical unit LUN to the array CARD(I1-I2) using A1 format.
If end of file is found,IEOF is set to 2.
Used by SHIFT and INIT2.
 
10.3 SUBROUTINE RDA4(LUN,CARD I1,I2)
 
As RDA1 but uses format A4.  Used by MESS.
(or whatever format is a fullword  on your machine)

10.4 SUBROUTINE WRA1(LUN,LINE,I1,I2).
 
Writes LINE(I1-I2) on logical unit LUN using format (1X,150A1).
Used by TERPRI.
 
10.5 SUBROUTINE WRA4(LINE,I1,I2).
 
As WRA1 but uses format (1X,100A4).  Used by MESS.
 
10.6 SUBROUTINE EJECT(LUN).
 
Skip to next page by writing format (1H1) on LUN.
 
10.7 SUBROUTINE REW(LUN).
 
Does REWIND LUN.
 
10.8 SUBROUTINE DMPIN(LUN,AREA,START,STOP)
 
Reads AREA(START-STOP)/LINE(I1-I2) in binary format from logical unit LUN.
Used by ROLLIN.
 
10.9 SUBROUTINE DMPOUT(LUN,AREA,START,STOP)
 
Writes AREA(START-STOP)/LINE(I1-I2) in binary format on logical unit LUN.
Used by ROLLOU.
 
(the two routines dmbin2 and dmpou2 use integer*2 format, if
you use integers as lisp pointers (i.e. in CAR and CDR arrays) these
routines must be the same as DMPIN and DMPOUT)
 
11.     Assembler routines.
 
11.1 GETCH AND PUTCH.
 
These routines are coded in assembler and used for moving bytes from/to
an array.  Calling format:
 
       CALL PUTCH(VEC,CH,I)
       Store a character CH at location I in the array VEC.
       CALL GETCH(VEC,CH,I)
 
The character in CH is left justified with space padding.
The array VEC behaves as a character array numbered 1,2,3... (1 = the
leftmost one).
 
11.2 MSLEFT
 
The time scheduling routine which is coded in assembler.
MSLEFT is only called from LISPF4, the LISP function clock().  Use
your own time routine, or skip it if you do not care about the
clock function. 
 
 
APPENDIX A
 
CROSS-REFERENCE LIST OF FORTRAN ROUTINES.
(this listing may be wrong and may not contain all routines
and may contain routines that are not included in this version.
This listing was produced on a computer with a program that no
longer exist, and no one has bothered to change the listing)

Routine:    Calling:
 
MAIN        INIT1   INIT2/ROLLIN    LISPF4  (LSPEX)
INIT1       GETCH
INIT2       IREAD   RDA1    SETCHT  MESS
LISPF4      All routines but:
            INIT1   INIT2   MAIN     (These are not called)
            REHASH  DMPIN  DMPOUT   (These and the following
            DAMPIN  DAMPUT  RDA1      are only called indirectly).
            RDA4    WRA1    WRA4
ROLLIN      MOVE    REHASH  REW     DMPIN  DMPOUT
ROLLOU      GARB    REW     DMPIN  DMPOUT
GARB        MARKL   MESS    IPRINT  PRIINT  REHASH
            ARRUTL
REHASH      GETCH
IREAD       RATOM   CONS    FPUSH   APUSH2  APOP2
RATOM       MATOM   MKNUM   MKREAL  CONS    SHIFT
SHIFT       LSPEX   MESS    GETCHT  RDA1    MATOM
RDNUMB      SHIFT   MKNUM   MKREAL
PRIN1       PRINAT  TERPRI  APUSH2  APUSH3  APOP2
            APOP3
PRINAT      PRIFLO  PRIINT  TERPRI  GETNUM  GTREAL
            GETCH   GETCHT  GETPN
PRIFLO      PRIINT
TERPRI      WRA1    PUTCH   MATOM
IPRINT      PRIN1   TERPRI
MATOM       GARB    PUTCH   GETCH
MKNUM       GARB    MESS    MKREAL
MKREAL      GARB
GETNUM      GTREAL
NCHARS      PRIN1   MKNUM   CONS    APUSH
LSPEX       IPRINT  MKNUM   CONS    MESS    TERPRI
MESS        RDA4    WRA4
XCALL
CONS        GARB
SUBST       CONS    APUSH   APOP    FPUSH
EQUAL       GTREAL  GETNUM  APUSH2  APOP2   COMPPN
GETPN       GETNUM
COMPPN      GETPN   GETCH
 
APPENDIX B
 
DEFINITION OF EVAL APPLY READ AND PRINT.

(The definition of eval-apply is not absolutely correct
as it is the definition of the old LISPF3 system that used an
A-list to keep variable bindings. This system use a stack instead.)
 
[DEFINEQ
[LISPF4
(LAMBDA (N)
        (PROG (EVALSW ERRFN ALIST *BACKTRACE *BACKTRACEFLG)
        (AND (EQ N 1) (PRINT "LISP F4 etc."))
        (RESET)
        (APPLY 'LISPX NIL)
        (ERROR 25 'LISPX NIL NIL]
[LISPX
(LAMBDA NIL
        (PROG NIL
         LOOP (PRINT (EVAL (READ)))
              (GO LOOP]
[EVAL
(LAMBDA (FORM)
        (COND ((OR (NUMBERP FORM) (STRINGP FORM)) FORM)
              ((ATOM FORM)
               [COND ((FORM_ON_ALIST?) (USE_BOUND_VALUE))
                     ((NEQ (CAR FORM) 'NOBIND) (CAR FORM))
                     (T (SETQ EVALSW T)
                        (SETQ ERRFN 'EVAL)
                        (EAPPLY (CAR FORM) (CDR FORM]
[APPLY
(LAMBDA (FN ARGS)
        (SETQ EVALSW NIL)
        (SETQ ERRFN 'APPLY)
        (SETQ FORM (CONS FN ARGS))
        (AND FN (EAPPLY FN ARGS]
[EAPPLY
(LAMBDA (FN ARGS)
        (COND ((LITATOM FN)
               [COND ((GETD FN) (APPLYFN2 (GETD FN) ARGS))
                     (T (ERROR 2 ERRFN FN FORM])
              (T (APPLYFN2 FN ARGS]
[APPLYFN1
(LAMBDA (FN ARGS)
        (COND ((SUBRP FN) (AND EVALSW (SETQ ARGS (EVLIS ARGS)))
                          (SAPPLY FN ARGS))
              ((FSUBRP FN) (SAPPLY FN ARGS))
              (T (ERROR 2 ERRFN FN FORM]
[APPLYFN2
(LAMBDA (FN ARGS)
        (COND ((NLISTP FN) (ERROR 2 ERRFN FN FORM))
              (T (SELECTQ (CAR FN)
                   (LAMBDA (AND EVALSW (SETQ ARGS (EVLIS ARGS)))
                           (LAPPLY FN ARGS))
                   (NLAMBDA (LAPPLY FN ARGS))
                   ((SUBR FSUBR) (APPLYFN1 (CDR FN) ARGS))
                   (FUNARG (PUSH ALIST)
                           (SETQ ALIST (CADDR FN))
                           (SETQ RES (EAPPLY (CADR FN) ARGS))
                           RES)
                   (ERROR 2 ERRFN FN FORM]
[LAPPLY
(LAMBDA (FN ARGS)
        (AND *BACKTRACEFLG
             (SETQ *BACKTRACE (CONS FORM *BACKTRACE)))
        (PUSH_ARGS_ON_ALIST)
        (SETQ RES (EVLAST (CDDR FN)))
        (AND *BACKTRACEFLG
             (SETQ *BACKTRACE (CDR *BACKTRACE)))
        RES]
[SAPPLY
(LAMBDA (FN ARGS)
        (JUMP_TO_CODE_FOR_FN]
[GETD
(LAMBDA (FN)
        (CONS ((GETPROP FN 'FNCELL))
              ((SUBRP FN) (CONS 'SUBR FN))
              ((FSUBRP FN) (CONS 'FSUBR FN]
[ERROR
(LAMBDA (ERRORN FN ARGS FORM)
        (APPLY 'SYSERROR
                (LIST ERRORN FN ARGS FORM]
[SYSSEROR
(LAMBDA (ERRORN FN ARGS FORM)
        (ERRORMESS ERRORN)
        (PRIN1 FN)
        (PRIN1 '-)
        (PRINT ARGS)
        (RESET]
 
]
 
(PRINT '"LISP F4 READ -- 7 FEB 79")
(PRINT '(VERSION 0))
[DEFINEQ
[BRSTK
[LAMBDA (X)
        (RPLACA BRSTK (PLUS X (CAR BRSTK)))
        (COND ((ZEROP (CAR BRSTK))
               (SETQ FLG NIL)
               (SETQ BRSTK (CDRBRSTK)))
              ((MINUSP (CAR BRSTK)) (SETQ OB NIL]]
 
[READ-L
(LAMBDA (S1 SN)
        (PROG (X)
         L    (SETQ X (READ-V))
              (AND (EQ X '%)) (GO R))
              (AND (NULL S1)
                   [SETQ S1 (SETQ SN (LIST (READ-S X]
                   (GO L))
              (COND ((NEQ X '%)
                     (RPLACD SN (LIST (READ-S X)))
                     (SETQ SN (CDR SN))
                     (GO L)))
              (SETQ X (LIST X))
              (SETQ X (READ-L X X))
              (RPLACD SN
                      (COND ((AND (LISTP (CDR X))
                                  (NULL (CDDR X)))
                             (CADR X))
                            (T X)))
         R    (RETURN S1)))]
 
[READ-S
(LAMBDA (X)
        (SELECTQ X
          (%( (READ-L))
          (%) (BRSTK 1) NIL)
          (%' (BRSTK 1)
              (PROG1 (LIST 'QUOTE (READ-S (READ-V)))
                     (BRSTK -1)))
          X))]
 
[READ-V
(LAMBDA NIL
        (OR FLG (SETQ OB (RATOM)))
        (SELECTQ OB
          (%[ (SETQ BRSTK (CONS 1 BRSTK)) '%( )
          (%] (SETQ FLG T) (BRSTK -1) '%) )
          (%( (BRSTK 1) OB)
          (%) (BRSTK -1) OB)
          OB))]
 
[*READ
[LAMBDA NIL
        (PROG (FLG OB (BRSTK (LIST 0)))
              (RETURN (READ-S (READ-V]]
 
]
(SETQQ READFNS (BRSTK READ-L READ-S READ-V *READ))
(SETQQ READCOMS "LISP F4 READ -- 7 FEB 79")
(SETQ READGENNR 0)
STOP
 
(PRINT '"LISP F4 PRINT .. 26 FEB 79")
(PRINT '(VERSION 0))
[DEFINEQ
[EDITFLAG
(LAMBDA NIL (SYSFLAG 7))]
 
[ESCAPEFLAG
(LAMBDA NIL (SYSFLAG 5))]
 
[LASTDEPTH
[LAMBDA (S)
        (PROG ((DEPTH LEVEL))
         L    (COND ((OR (GREATERP DEPTH (PRINTLEVEL))
                         (NLISTP S))
                     (RETURN (DIFFERECE DEPTH LEVEL)))
                    (T (SETQ DEPTH (ADD1 DEPTH))
                       (SETQ S (UNKWLASTELT S))
                       (GO L]]
 
[LINEBREAK
[LAMBDA (S)
        (COND ((NULL PPBREAK) (SPACES 1))
              ([AND (LISTP S)
                    (LITATOM (CAR S))
                    (EQUAL '(FSUBR . QUOTE) (GETPROP (CAR S) 'FNCELL]
               [SETQ OLDCOL
                     (LMARG (COND ((LESSP (NCHARS S) COMMENTLEN)
                                    COMMENTCOL)
                                  (T (TERPRI) (TERPRI) 10]
               (TAB (LMARG))
               (PPLAG NIL))
              [(AND (EQ 1ST 'PROG) (GREATERP I 1))
               (TAB (PLUS (LMARG)
                          (COND ((ATOM S) -5) (0]
              ((OR *LBEFORE (LISTP S)) (TAB (LMARG)))
              ((SPACES 1]]
 
[LMARG
(LAMBDA (X) (IOTAB 7 X))]
 
[MIN
(LAMBDA (X Y) (COND ((LESSP X Y) X) (T Y)))]
 
[PPFLAG
(LAMBDA L (APPLY 'SYSFLG (CONS 2 L)))]
 
[PRINT-A
(LAMBDA (A)
        (RPT *NKW '(PRIN1 "'"))
        (PRIN0 A (ESCAPFLAG)))]
 
[PRINT-L
(LAMBDA (S RP)
        (PROG (( I O)
               (LEVEL (ADD1 LEVEL))
               (LMARG (LMARG))
               (OLDCOL O)
               (1ST (CAR S))
               PPBREAK X)
              (RPT *NKW '(PRIN1 "'"))
              (PRIN1 (COND (RP "(")
                           ((AND (PPFLG)
                                 (GREATERP
                                   (SETQ RP (LASTDEPTH S))
                                   *MAXPAR))
                             "[")
                            (T (SETQ RP O) "(")))
              [COND ((PPFLAG)
                     [SETQ PPBREAK
                           (AND (LESSP LEVEL (PRINTLEVEL))
                                (OR (EDITFLAG)
                                    (GREATERP
                                      (PLUS (PRINTPOS)
                                            (NCHARS S))
                                      (RMARG]
                     (LMARG (MIN (PLUS -3 (RMARG))
                                 (ADD1 (PRINTPOS]
         L    (SETQ X (UNKWOTE (CAR S) T))
              (OR (ZEROP I) (LINEBREAK X))
              (PRINT-S X
                (AND (NULL (SETQ S (CDR S))) RP))
              (SETQ I (ADD1 I))
              [AND (PPFLG)
                   (EQ I 1)
                   (NLISTP 1ST)
                   (LESSP (PRINTPOS)
                          (WEIGH (LMARG) (RMARG) *WEIGHT 1))
                   (LMARG (ADD1 (PRINTPOS]
              (COND ((NULL S))
                    ((NLISTP S) (PRIN1 " . ") (PRINT-A S))
                    (EQ I (PRINTLENGTH)) (PRIN1 "---"))
                    ((GO L)))
              (SELECTQ RP
                (0 (PRIN1 ")"))
                (1 (PRIN1 "]"))
                NIL)
              (LMARG LMARG)
              (RETURN S)))]
 
[PRINT-S
[LAMBDA (S RP)
        (AND (EQ LEVEL (PRINTLEVEL)) (SETQ S '...))
        (COND ((NLISP S) (PRINT-A S) (SETQ *LBEFORE))
              (T (PRINT-L S
                    (SELECTQ RP ((0 NIL) RP) (SUB1 RP)))
                 (SETQ *LBEFORE T)
                 (SELECTQ OLDCOL
                   (0)
                   (PROG1 (SELECTQ
                            (LMARG OLDCOL)
                            (10 (TERPRI) (TERPRI))
                            NIL)
                          (PPFLAG T]]
 
[QFLAG
(LAMBDA NIL (SYSFLAG 3))]
 
[RMARG
(LAMBDA NIL (IOTAB 8))]
 
[TAB
(LAMBDA (X)
        (AND (GREATERP (PRINTPOS) (SUB1 X)) (TERPRI))
        (PRINTPOS X))]
 
[UNKWLASTELT
[LAMBDA (L)
        (PROG ((I O))
         L    (RETURN
                (COND ((NULL (CDR L)) (UNKWOTE (CAR L)))
                      ((EQ I (PRINTLENGTH)) '---)
                      (T (SETQ I (ADD1 I))
                         (SETQ L (CDR L))
                         (GO L]]
 
[UNKWOTE
(LAMBDA (S FLAG)
        (PROG NIL
              (SETQ *COUNT 0)
         L    (AND (QFLAG)
                   (LISTP S)
                   (EQ (CAR S) 'QUOTE)
                   (LISTP (CDR S))
                   (NULL (CDDR S))
                   (SETQ *COUNT (ADD1 *COUNT))
                   (SETQ S (CADR S))
                   (GO L))
              (AND FLAG (SETQ *NKW *COUNT))
              (RETURN S)))]
 
[WEIGH
(LAMBDA (X1 X2 W1 W2)
        (QUOTIENT
          (PLUS (TIMES X1 W1) (TIMES X2 W2))
          (PLUS W1 W2)))]
 
[*PRINT
(LAMBDA (X)
        (PROG ((COMMENTCOL
                 (QUOTIENT (TIMES 2 (RMARG)) 3))
               [COMMENTLEN (PLUS -20 (TIMES 2 (RMARG]
               (LEVEL 0)
               (OLDCOL 0)
               *COUNT *LBEFORE *NKW)
              (PRINT-S (UNKWOTE X T))
              (TERPRI)
              (RETURN X)))]
 
]
        (EDITFLAG ESCAPEFLAG LASTDEPTH LINEBREAK LMARG MIN PPFLAG PRINT-A
         PRINT-L PRINT-S QFLAG RMARG TAB UNKWLASTELT UNKWOTE WEIGH
         *PRINT)
(SETQQ PRINTVARS (*MAXPAR *WEIGHT))
(SETQQ PRINTCOMS "LISP F4 PRINT -- 26 FEB 79")
(SETQ PRINTGENNR 0)
(SETQQ *MAXPAR 3)
(SETQQ *WEIGHT 8)
STOP
 
APPENDIX C
 
LIST OF FUNCTIONS.
 
NAME(ARGS)                                  NAME(ARGS)
 
ABS(N)                                      ADDLIST(A L)
ADDPROP(A P V)                              ADD1(N)
ADVISE(FN WHEN WHERE WHAT)                  ALIST()
ALPHORDER(A B)                              AND L
APPEND(L1 L2)                               APPLY(FN L)
APPLYA(FN L AL)                             APPLYSTK(FN L POS)
APPLY*(FN . L)                              ASSOC(A L)
ATOM(S)
 
BINDENV('V)
BREAK 'L                                    BREAK0(FN WHEN COMS)
BREAK1('BRKEXPR 'BRKWHEN 'BRKFN 'BRKCOMS)
BREAK11(BRKEXPR BRKWHEN BRKFN BRKCOMS)
 
CAAAR(S)                                    CAADR(S)
CAAR(S)                                     CADAR(S)
CADDR(S)                                    CADR(S)
CAR(S)                                      CDAAR(S)
CDADR(S)                                    CDAR(S)
CDDAR(S)                                    CDDDR(S)
CDDR(S)                                     CDR(S)
CHTAB(A N)                                  CLOCK()
CLOSE(FILE)                                 CONCAT
COND(...)                                   CONS(S1 S2)
COPY(S)                                     CURFILE('FILE)
 
DE('FN 'ARGS . 'BODY)                       DEFINEQ 'L
DF('FN 'ARGS . 'BODY)                       DIFFERENCE(N1 N2)
DSORT(L)
 
EDITF('FN . 'EDCOM)                         EDITS(S EDCOM)
EJECT()                                     EQ(S1 S2)
EQUAL(S1 S2)                                ERRORB()
ERRORMESS(N)                                ERRORN()
ERRORSET(ERRORFORM ERRFLG)                  EVAL(S)
EVALA(S AL)                                 EVLIS(L)
EVSTK(S POS)                                EXIT()
 
FUNCTION('FN)
 
GCGAG(FLAG)                                 GENSYM()
GETD(FN)                                    GETINT(S FORM)
GO*('LAB)                                   GREATERP(N1 N2)
 
INUNIT(N)                                   IOTAB(N1 N2)
 
LAST(L)                                     LENGTH(L)
LESSP(N1 N2)                                LISPX()
LIST L                                      LISTP(S)
LITATOM(S)                                  LOAD(FILE)
 
MAKEFILE(FILE FLAG)                         MAP(L FN1 FN2)
MAPC(L FN1 FN2)                             MAPLIST L FN1 FN2)
MEMB(A L)                                   MEMBER(A L)
MINUS(N)                                    MINUSP(N)
MKATOM(S)                                   MKSTRING(S)
 
NCHARS(S)                                   NCONC(L1 L2)
NLISTP(S)                                   NTH(L N)
NULL(S)                                     NUMBERP(S)
 
OBLIST(A)                                   OPEN(FILE OPT N)
OPEN0(FILE INFLG BINFLG)                    OR L
OUTUNIT(N)
 
PACK(S FLAG)                                PLUS L
PP 'L                                       PRINT(S)
PRINTDEF(S)                                 PRINTL L
PRINTLENGTH(N)                              PRINTLEVEL(N)
PRINTL-SP L                                 PRINTPOS(N)
PRIN0(S ESCFLG PPFLG)                       PRIN1(S)
PRIN2(S)                                    PROG(...)
PROGN L                                     PROG1 L
PROMPTTEXT(TXT)
PUTPROP(A P V)                              PUTD(FN S)
PUTINT(S X FORM)
 
QUOTE('S)                                   QUOTIENT(N1 N2)
 
RATOM()                                     READ()
READC()                                     READPOS()
READVISE 'L                                 REBREAK 'L
RECLAIM(N)                                  REMOVE(A L)
REMPROP(A P)                                RESET()
RETURN(S)                                   REVERSE(L)
REWIND(N)                                   ROLLIN(N)
ROLLOUT(N)                                  RPLACA(S1 S2)
RPLACD(S1 S2)                               RPLSTRING(S1 N S2)
RPT(N S)                                    RPTQ(N 'S)
 
SASSOC(A L)                                 SAVEDEF(FN)
SELECTQ(...)                                SET(A S)
SETQ('A S)                                  SETQQ(A S)
SIGN(N)                                     SPACES(N)
STRALLOC(N C)                               STREQUAL(S1 S2)
STRINGP(S)                                  SUBPR(A B S)
SUBSTRING(S N1 N2)                          SUB1(N)
SYSERROR(ERRTYPE FN ARG FORM)               SYSFLAG(N)
 
TERPRI()                                    TIMES L
TRACE 'L
 
UNADVISE 'L                                 UNBREAK 'L
UNPACK(S FLAG)                              UNSAVEDEF(FN)
UNTRACE 'L
 
VIRGINFN(FN)
 
XCALL(FN L)
 
ZEROP(N)
 
APPENDIX D
 
REFERENCES.
 
Ha 75   A. Haraldsson:      "LISP-DETAILS.  INTERLISP 360/370."
                             DLU 75/9
Sc 67   H. Schon etc.       "An efficient machine independent
                             procedure for ..." CACM Aug 1967.
